/*!
 * Remove unused CSS 
 * https://github.com/commeta/remove-unused-css
 * Copyright 2025 Commeta
 * Released under the GPL v3 or MIT license
 */
 
(function () {
    const c = { CHECK_INTERVAL: 1000, SERVER_ENDPOINT: '/remove-unused-css/remove-unused-css.php', BUTTON_ID: 'unused-css-button', MENU_ID: 'unused-css-menu', SETTINGS_ID: 'unused-css-settings' }; let s = { unusedSelectors: new Map(), styleSheetsInfo: new Map(), isProcessing: false, totalUnusedCount: 0, currentPageSelectors: new Set(), settings: { media: true, media_print: true, keyframes: true, font_face: true, import: true, supports: true, page: true, charset: true, counter_style: true, layer: true, pseudo_classes: true, pseudo_elements: true, attribute_selectors: true, css_variables: true, vendor_prefixes: true, adjacent_selectors: true, child_selectors: true, general_siblings: true, css_functions: true, animations: true, transforms: true, transitions: true, percentages: true, escapes: true, colors: true, gradients: true, filters: true, masks: true, nth_selectors: true, logical_selectors: true } }; class CSSUtils {
        static isSafeSelectorToCheck(selector) { if (!selector) return false; const t = selector.trim(); if (s.settings.pseudo_classes && /:[a-z-]+(\([^)]*\))?/i.test(t)) return false; if (s.settings.pseudo_elements && /::[a-z-]+/i.test(t)) return false; if (s.settings.attribute_selectors && /\[[\w\-="\':\s]*\]/.test(t)) return false; if (s.settings.css_variables && /--[\w\-]+/.test(t)) return false; if (s.settings.vendor_prefixes && /-webkit-|-moz-|-ms-|-o-/.test(t)) return false; if (s.settings.adjacent_selectors && /\+/.test(t)) return false; if (s.settings.child_selectors && />/.test(t)) return false; if (s.settings.general_siblings && /~/.test(t)) return false; if (s.settings.css_functions && /\(/.test(t)) return false; if (s.settings.animations && /animation|keyframes/i.test(t)) return false; if (s.settings.transforms && /transform/i.test(t)) return false; if (s.settings.transitions && /transition/i.test(t)) return false; if (s.settings.percentages && /\d+%/.test(t)) return false; if (s.settings.escapes && /\\\\/.test(t)) return false; if (s.settings.colors && /rgb\(|rgba\(|hsl\(|hsla\(/i.test(t)) return false; if (s.settings.gradients && /linear-gradient|radial-gradient/i.test(t)) return false; if (s.settings.filters && /filter|backdrop-filter/i.test(t)) return false; if (s.settings.masks && /mask|clip-path/i.test(t)) return false; if (s.settings.nth_selectors && /nth-child|nth-of-type/i.test(t)) return false; if (s.settings.logical_selectors && /not\(|is\(|where\(|has\(/i.test(t)) return false; const crit = ['html', 'body', '*', ':root', 'head', 'title', 'meta', 'link', 'script', 'style', 'base']; if (crit.includes(t.toLowerCase())) return false; const safe = [/^[a-zA-Z][a-zA-Z0-9-_]*$/, /^\.[a-zA-Z][a-zA-Z0-9-_]*$/, /^#[a-zA-Z][a-zA-Z0-9-_]*$/, /^[a-zA-Z][a-zA-Z0-9-_]*\.[a-zA-Z][a-zA-Z0-9-_]*$/, /^[a-zA-Z][a-zA-Z0-9-_]*#[a-zA-Z][a-zA-Z0-9-_]*$/]; return safe.some(pattern => pattern.test(t)); }
        static async loadStyleSheetContent(href) { try { const response = await fetch(href, { method: 'GET', mode: 'cors', cache: 'no-cache', credentials: 'omit' }); if (!response.ok) { throw new Error(`HTTP ${response.status}: ${response.statusText}`); } return await response.text(); } catch (error) { console.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å: ${href}`, error); return ''; } }
        static parseCSSText(cssText) { try { const styleElement = document.createElement('style'); styleElement.textContent = cssText; document.head.appendChild(styleElement); const rules = styleElement.sheet?.cssRules || null; document.head.removeChild(styleElement); return rules; } catch (error) { console.warn('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ CSS:', error); return null; } }
        static isLocalUrl(url) { if (!url) return true; try { const urlObj = new URL(url, window.location.origin); return urlObj.origin === window.location.origin; } catch { return false; } }
        static normalizeSelector(selector) { return selector?.trim() || ''; }
        static getRelativePathFromHref(href) { if (!href) return 'external'; try { const url = new URL(href, window.location.origin); return url.pathname.substring(1); } catch { return href; } }
        static getCurrentPageCSSFiles() { const cssFiles = new Set(); document.querySelectorAll('link[rel="stylesheet"]').forEach(link => { if (link.href) { const relativePath = this.getRelativePathFromHref(link.href); cssFiles.add(relativePath); } }); return cssFiles; }
    }
    class SelectorManager {
        static addSelector(selectorText, href, media = null) { if (!selectorText) return; const selectors = selectorText.split(',').map(s => CSSUtils.normalizeSelector(s)); const relativePath = CSSUtils.getRelativePathFromHref(href); if (!s.currentPageSelectors.has(relativePath)) return; selectors.forEach(selector => { if (selector && !s.unusedSelectors.has(selector)) { const isSafeToCheck = CSSUtils.isSafeSelectorToCheck(selector); s.unusedSelectors.set(selector, { href: relativePath, media, used: false, safe: isSafeToCheck }); } }); if (!s.styleSheetsInfo.has(relativePath)) { s.styleSheetsInfo.set(relativePath, []); } s.styleSheetsInfo.get(relativePath).push({ selector: selectorText, media }); }
        static checkSelectorsUsage() { let unusedCount = 0; for (const [selector, info] of s.unusedSelectors.entries()) { if (!info.used) { try { const exists = document.querySelector(selector); if (exists) { info.used = true; } else if (info.safe) { unusedCount++; } } catch (error) { info.used = true; } } } s.totalUnusedCount = unusedCount; UIManager.updateButton(unusedCount); }
        static groupSelectorsByFile() { const result = {}; for (const [selector, info] of s.unusedSelectors.entries()) { if (info.used) continue; const href = info.href; if (!result[href]) result[href] = []; result[href].push({ selector, media: info.media }); } return result; }
    }
    class RuleProcessor {
        static async processStyleSheet(sheet) { let rules; try { rules = sheet.cssRules; } catch (error) { if (error.name === 'SecurityError') { rules = await this.handleCrossOriginStyleSheet(sheet); } else { console.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–∞–≤–∏–ª–∞:`, error); return; } } if (!rules) return; for (const rule of rules) { await this.processRule(rule, sheet.href || 'external'); } }
        static async handleCrossOriginStyleSheet(sheet) { if (!sheet.href || !CSSUtils.isLocalUrl(sheet.href)) { console.warn(`–§–∞–π–ª –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: ${sheet.href}`); return null; } const cssText = await CSSUtils.loadStyleSheetContent(sheet.href); return cssText ? CSSUtils.parseCSSText(cssText) : null; }
        static async processRule(rule, href) { switch (rule.type) { case CSSRule.STYLE_RULE: SelectorManager.addSelector(rule.selectorText, href); break; case CSSRule.MEDIA_RULE: this.processMediaRule(rule, href); break; case CSSRule.IMPORT_RULE: if (rule.styleSheet) { await this.processStyleSheet(rule.styleSheet); } break; case CSSRule.SUPPORTS_RULE: for (const subRule of rule.cssRules) { await this.processRule(subRule, href); } break; case CSSRule.KEYFRAMES_RULE: case CSSRule.FONT_FACE_RULE: case CSSRule.PAGE_RULE: case CSSRule.NAMESPACE_RULE: break; } }
        static async processMediaRule(mediaRule, href) { const mediaText = mediaRule.media.mediaText; for (const rule of mediaRule.cssRules) { if (rule.type === CSSRule.STYLE_RULE) { SelectorManager.addSelector(rule.selectorText, href, mediaText); } else if (rule.type === CSSRule.MEDIA_RULE) { await this.processMediaRule(rule, href); } } }
    }
    class SettingsManager {
        static async loadSettings() { try { const response = await fetch(c.SERVER_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Action': 'settings' }, body: JSON.stringify({ action: 'load' }) }); if (!response.ok) throw new Error(`HTTP ${response.status}`); const result = await response.json(); if (result.success && result.data && result.data.settings) { return result.data.settings; } return s.settings; } catch (error) { console.warn('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫:', error); return s.settings; } }
        static async saveSettings(settings) { try { const response = await fetch(c.SERVER_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Action': 'settings' }, body: JSON.stringify({ action: 'save', settings }) }); if (!response.ok) throw new Error(`HTTP ${response.status}`); const result = await response.json(); if (result.success) { s.settings = settings; if (result.data && result.data.need_reload) { UIManager.showNotification('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑–º–µ–Ω–µ–Ω—ã. –°—Ç—Ä–∞–Ω–∏—Ü–∞ –±—É–¥–µ—Ç –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω–∞.', 'info'); setTimeout(() => window.location.reload(), 2000); return true; } } return false; } catch (error) { console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫:', error); throw error; } }
        static showSettings() { const overlay = document.createElement('div'); overlay.id = c.SETTINGS_ID; overlay.style.cssText = `position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:10001;display:flex;align-items:center;justify-content:center;`; const modal = document.createElement('div'); modal.style.cssText = `background:white;border-radius:8px;padding:20px;max-width:600px;width:90%;max-height:80%;overflow-y:auto;color:#333;`; const title = document.createElement('h3'); title.textContent = '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞—â–∏—Ç—ã —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤'; title.style.cssText = `margin:0 0 15px 0;color:#333;font-size:18px;`; const settings = [{ key: 'media', label: '@media –∑–∞–ø—Ä–æ—Å—ã' }, { key: 'media_print', label: '@media print –∑–∞–ø—Ä–æ—Å—ã' }, { key: 'keyframes', label: '@keyframes –∞–Ω–∏–º–∞—Ü–∏–∏' }, { key: 'font_face', label: '@font-face —à—Ä–∏—Ñ—Ç—ã' }, { key: 'import', label: '@import –∏–º–ø–æ—Ä—Ç—ã' }, { key: 'supports', label: '@supports –ø–æ–¥–¥–µ—Ä–∂–∫–∞' }, { key: 'page', label: '@page –ø–µ—á–∞—Ç—å' }, { key: 'charset', label: '@charset –∫–æ–¥–∏—Ä–æ–≤–∫–∞' }, { key: 'counter_style', label: '@counter-style —Å—á–µ—Ç—á–∏–∫–∏' }, { key: 'layer', label: '@layer —Å–ª–æ–∏' }, { key: 'pseudo_classes', label: '–ü—Å–µ–≤–¥–æ-–∫–ª–∞—Å—Å—ã (:hover, :active)' }, { key: 'pseudo_elements', label: '–ü—Å–µ–≤–¥–æ-—ç–ª–µ–º–µ–Ω—Ç—ã (::before, ::after)' }, { key: 'attribute_selectors', label: '–ê—Ç—Ä–∏–±—É—Ç–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã [attr]' }, { key: 'css_variables', label: 'CSS-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (--variable)' }, { key: 'vendor_prefixes', label: '–ë—Ä–∞—É–∑–µ—Ä–Ω—ã–µ –ø—Ä–µ—Ñ–∏–∫—Å—ã (-webkit-, -moz-)' }, { key: 'adjacent_selectors', label: '–°–æ—Å–µ–¥–Ω–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã (+)' }, { key: 'child_selectors', label: '–î–æ—á–µ—Ä–Ω–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã (>)' }, { key: 'general_siblings', label: '–û–±—â–∏–µ –±—Ä–∞—Ç—Å–∫–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã (~)' }, { key: 'css_functions', label: 'CSS-—Ñ—É–Ω–∫—Ü–∏–∏ (calc, var, url)' }, { key: 'animations', label: '–ê–Ω–∏–º–∞—Ü–∏–∏ –∏ –ø–µ—Ä–µ—Ö–æ–¥—ã' }, { key: 'transforms', label: '–¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏' }, { key: 'transitions', label: '–ü–µ—Ä–µ—Ö–æ–¥—ã' }, { key: 'percentages', label: '–ü—Ä–æ—Ü–µ–Ω—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è' }, { key: 'escapes', label: '–≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã' }, { key: 'colors', label: '–¶–≤–µ—Ç–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (rgb, hsl)' }, { key: 'gradients', label: '–ì—Ä–∞–¥–∏–µ–Ω—Ç—ã' }, { key: 'filters', label: '–§–∏–ª—å—Ç—Ä—ã' }, { key: 'masks', label: '–ú–∞—Å–∫–∏ –∏ –æ–±—Ä–µ–∑–∫–∞' }, { key: 'nth_selectors', label: 'nth-—Å–µ–ª–µ–∫—Ç–æ—Ä—ã' }, { key: 'logical_selectors', label: '–õ–æ–≥–∏—á–µ—Å–∫–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã (not, is, where, has)' }]; modal.appendChild(title); settings.forEach(setting => { const item = document.createElement('div'); item.style.cssText = `margin-bottom:10px;display:flex;align-items:center;`; const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.id = setting.key; checkbox.checked = s.settings[setting.key]; checkbox.style.cssText = `margin-right:10px;`; const label = document.createElement('label'); label.htmlFor = setting.key; label.textContent = setting.label; label.style.cssText = `cursor:pointer;flex:1;`; item.appendChild(checkbox); item.appendChild(label); modal.appendChild(item); }); const buttons = document.createElement('div'); buttons.style.cssText = `margin-top:20px;display:flex;gap:10px;justify-content:flex-end;`; const saveBtn = document.createElement('button'); saveBtn.textContent = '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å'; saveBtn.style.cssText = `padding:8px 16px;background:#27ae60;color:white;border:none;border-radius:4px;cursor:pointer;`; saveBtn.onclick = async () => { const newSettings = {}; settings.forEach(setting => { const checkbox = document.getElementById(setting.key); newSettings[setting.key] = checkbox.checked; }); try { await SettingsManager.saveSettings(newSettings); overlay.remove(); UIManager.showNotification('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞...', 'success'); setTimeout(() => window.location.reload(), 1000); } catch (error) { UIManager.showNotification('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫', 'error'); } }; const cancelBtn = document.createElement('button'); cancelBtn.textContent = '–û—Ç–º–µ–Ω–∞'; cancelBtn.style.cssText = `padding:8px 16px;background:#95a5a6;color:white;border:none;border-radius:4px;cursor:pointer;`; cancelBtn.onclick = () => overlay.remove(); buttons.appendChild(cancelBtn); buttons.appendChild(saveBtn); modal.appendChild(buttons); overlay.appendChild(modal); overlay.onclick = e => { if (e.target === overlay) overlay.remove(); }; document.body.appendChild(overlay); }
    }
    class UIManager {
        static createFloatingButton() { if (document.getElementById(c.BUTTON_ID)) return; const container = document.createElement('div'); container.style.cssText = `position:fixed;bottom:20px;right:20px;z-index:9999;`; const button = document.createElement('button'); button.id = c.BUTTON_ID; button.innerHTML = '0'; button.title = '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö CSS —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤'; button.style.cssText = `width:50px;height:50px;background-color:#e74c3c;color:white;border:none;border-radius:50%;font-size:14px;font-weight:bold;cursor:pointer;box-shadow:0 4px 8px rgba(0,0,0,0.3);transition:all 0.3s ease;display:flex;align-items:center;justify-content:center;`; const menu = document.createElement('div'); menu.id = c.MENU_ID; menu.style.cssText = `position:absolute;bottom:60px;right:0;background:white;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);min-width:200px;opacity:0;transform:translateY(10px);transition:all 0.3s ease;pointer-events:none;border:1px solid #ddd;`; const menuItems = [{ text: '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ', action: 'save', icon: 'üíæ' }, { text: '–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª—ã', action: 'generate', icon: '‚öôÔ∏è' }, { text: '–ü–æ–∫–∞–∑–∞—Ç—å –æ—Ç—á–µ—Ç', action: 'report', icon: 'üìä' }, { text: '–ù–∞—Å—Ç—Ä–æ–π–∫–∏', action: 'settings', icon: '‚öôÔ∏è' }]; menuItems.forEach((item, index) => { const menuItem = document.createElement('div'); menuItem.style.cssText = `padding:12px 16px;cursor:pointer;border-bottom:${index < menuItems.length - 1 ? '1px solid #eee' : 'none'};display:flex;align-items:center;gap:8px;font-size:14px;color:#333;transition:background-color 0.2s ease;`; menuItem.innerHTML = `${item.icon} ${item.text}`; menuItem.addEventListener('mouseenter', () => { menuItem.style.backgroundColor = '#f8f9fa'; }); menuItem.addEventListener('mouseleave', () => { menuItem.style.backgroundColor = 'transparent'; }); menuItem.addEventListener('click', () => { this.handleMenuClick(item.action); this.hideMenu(); }); menu.appendChild(menuItem); }); button.addEventListener('mouseenter', () => { if (!s.isProcessing) { button.style.transform = 'scale(1.1)'; button.style.backgroundColor = '#c0392b'; } }); button.addEventListener('mouseleave', () => { if (!s.isProcessing) { button.style.transform = 'scale(1)'; button.style.backgroundColor = '#e74c3c'; } }); button.addEventListener('click', (e) => { e.stopPropagation(); this.toggleMenu(); }); container.appendChild(button); container.appendChild(menu); document.body.appendChild(container); document.addEventListener('click', () => { this.hideMenu(); }); menu.addEventListener('click', (e) => { e.stopPropagation(); }); }
        static toggleMenu() { const menu = document.getElementById(c.MENU_ID); if (!menu) return; const isVisible = menu.style.opacity === '1'; if (isVisible) { this.hideMenu(); } else { this.showMenu(); } }
        static showMenu() { const menu = document.getElementById(c.MENU_ID); if (!menu) return; menu.style.opacity = '1'; menu.style.transform = 'translateY(0)'; menu.style.pointerEvents = 'auto'; }
        static hideMenu() { const menu = document.getElementById(c.MENU_ID); if (!menu) return; menu.style.opacity = '0'; menu.style.transform = 'translateY(10px)'; menu.style.pointerEvents = 'none'; }
        static async handleMenuClick(action) { if (s.isProcessing) return; if (action === 'settings') { SettingsManager.showSettings(); return; } const button = document.getElementById(c.BUTTON_ID); if (!button) return; try { s.isProcessing = true; button.innerHTML = '...'; button.style.backgroundColor = '#f39c12'; button.style.cursor = 'not-allowed'; button.disabled = true; const data = SelectorManager.groupSelectorsByFile(); if (Object.keys(data).length === 0) { this.showNotification('–°–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ', 'info'); return; } if (action === 'save') { await this.saveDataToServer(data); } else if (action === 'generate') { await this.generateFiles(data); } else if (action === 'report') { this.showDetailedReport(data); } } catch (error) { console.error('–û—à–∏–±–∫–∞:', error); this.showNotification('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞', 'error'); } finally { s.isProcessing = false; if (button) { button.innerHTML = s.totalUnusedCount.toString(); button.style.backgroundColor = '#e74c3c'; button.style.cursor = 'pointer'; button.disabled = false; } } }
        static showDetailedReport(data) { let totalSelectors = 0; let reportHtml = '<div style="font-family:monospace;font-size:12px;line-height:1.4;">'; reportHtml += '<h3 style="margin:0 0 10px 0;color:#fff;">üîç –û—Ç—á–µ—Ç –æ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Å–µ–ª–µ–∫—Ç–æ—Ä–∞—Ö</h3>'; reportHtml += '<div style="margin-bottom:10px;padding:8px;background:#f8f9fa;border-radius:4px;color:#000;">'; reportHtml += '<strong>‚ö†Ô∏è –í–Ω–∏–º–∞–Ω–∏–µ:</strong> –ü–æ–∫–∞–∑–∞–Ω—ã —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏.'; reportHtml += '</div>'; for (const [file, selectors] of Object.entries(data)) { if (selectors.length === 0) continue; totalSelectors += selectors.length; reportHtml += `<div style="margin-bottom:10px;border:1px solid #ddd;border-radius:4px;padding:8px;">`; reportHtml += `<strong style="color:#fff;font-weight:bolder;">üìÑ ${file}</strong> (${selectors.length} —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤)<br>`; const selectorList = selectors.slice(0, 10).map(s => s.selector).join(', '); reportHtml += `<small style="color:#fff;">${selectorList}`; if (selectors.length > 10) { reportHtml += ` ... –∏ –µ—â–µ ${selectors.length - 10}`; } reportHtml += '</small></div>'; } reportHtml += `<div style="margin-top:10px;padding:8px;background:#e8f5e8;border-radius:4px;border:1px solid #4caf50;color:#000;">`; reportHtml += `<strong>üìä –ò—Ç–æ–≥–æ: ${totalSelectors} —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ –≤ ${Object.keys(data).length} —Ñ–∞–π–ª–∞—Ö</strong>`; reportHtml += '</div></div>'; this.showLargeNotification(reportHtml, 'info', true); }
        static async saveDataToServer(data) { try { const response = await fetch(c.SERVER_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Action': 'save' }, body: JSON.stringify(data) }); if (!response.ok) { throw new Error(`HTTP ${response.status}: ${response.statusText}`); } const result = await response.json(); if (result.success) { const selectorsCount = Object.values(data).reduce((sum, selectors) => sum + selectors.length, 0); this.showNotification(`–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤: ${selectorsCount} –∏–∑ ${Object.keys(data).length} —Ñ–∞–π–ª–æ–≤`, 'success'); } else { throw new Error(result.error || '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'); } } catch (error) { console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:', error); throw error; } }
        static async generateFiles(data) { try { const response = await fetch(c.SERVER_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Action': 'generate' }, body: JSON.stringify(data) }); if (!response.ok) { throw new Error(`HTTP ${response.status}: ${response.statusText}`); } const result = await response.json(); if (result.success) { this.showGenerationStatistics(result); } else { throw new Error(result.error || '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'); } } catch (error) { console.error('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:', error); throw error; } }
        static showGenerationStatistics(result) { const stats = result.statistics || {}; const message = `–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n\nüìÅ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Ñ–∞–π–ª–æ–≤: ${stats.processed_files || 0}\nüìÑ –°–æ–∑–¥–∞–Ω–æ —Ñ–∞–π–ª–æ–≤: ${stats.generated_files || 0}\nüíæ –û–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—ã–π —Ñ–∞–π–ª: ${stats.combined_file ? '–î–∞' : '–ù–µ—Ç'}\nüìä –û—á–∏—â–µ–Ω–æ –±–∞–π—Ç: ${this.formatBytes(stats.bytes_saved || 0)}\nüéØ –£–¥–∞–ª–µ–Ω–æ —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤: ${stats.selectors_removed || 0}\n‚ö° –†–∞–∑–º–µ—Ä –¥–æ: ${this.formatBytes(stats.original_size || 0)}\n‚ö° –†–∞–∑–º–µ—Ä –ø–æ—Å–ª–µ: ${this.formatBytes(stats.final_size || 0)}`; this.showLargeNotification(message, 'success'); }
        static formatBytes(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]; }
        static updateButton(count) { const button = document.getElementById(c.BUTTON_ID); if (button) { button.innerHTML = count.toString(); if (count > 0) { button.style.backgroundColor = '#e74c3c'; } else { button.style.backgroundColor = '#27ae60'; } } }
        static showNotification(message, type = 'info') { this.createNotification(message, type, false); }
        static showLargeNotification(message, type = 'info', isHtml = false) { this.createNotification(message, type, true, isHtml); }
        static createNotification(message, type = 'info', isLarge = false, isHtml = false) { const existingNotification = document.getElementById('unused-css-notification'); if (existingNotification) { existingNotification.remove(); } const notification = document.createElement('div'); notification.id = 'unused-css-notification'; const colors = { success: '#27ae60', error: '#e74c3c', info: '#3498db' }; const baseStyles = { position: 'fixed', top: '20px', right: '20px', padding: isLarge ? '20px' : '12px 20px', backgroundColor: colors[type] || colors.info, color: 'white', borderRadius: '8px', fontSize: '14px', zIndex: '10000', boxShadow: '0 4px 12px rgba(0,0,0,0.3)', maxWidth: isLarge ? '500px' : '300px', maxHeight: isLarge ? '400px' : 'auto', overflowY: isLarge ? 'auto' : 'visible', wordWrap: 'break-word', whiteSpace: isLarge ? 'pre-line' : 'normal', fontFamily: isLarge ? 'monospace' : 'inherit' }; Object.assign(notification.style, baseStyles); if (isHtml) { notification.innerHTML = message; } else { notification.textContent = message; } if (isLarge) { const closeButton = document.createElement('button'); closeButton.innerHTML = '‚úï'; closeButton.style.cssText = `position:absolute;top:10px;right:10px;background:rgba(255,255,255,0.2);border:none;color:white;width:20px;height:20px;border-radius:50%;cursor:pointer;font-size:12px;display:flex;align-items:center;justify-content:center;`; closeButton.addEventListener('click', () => { notification.remove(); }); notification.appendChild(closeButton); } document.body.appendChild(notification); const timeout = isLarge ? 20000 : 5000; setTimeout(() => { if (notification.parentNode) { notification.remove(); } }, timeout); }
    }
    class UnusedCSSDetector {
        static async init() { try { s.settings = await SettingsManager.loadSettings(); s.currentPageSelectors = CSSUtils.getCurrentPageCSSFiles(); await this.loadStyleSheets(); UIManager.createFloatingButton(); this.startPeriodicCheck(); console.log('Remove Unused CSS –∑–∞–≥—Ä—É–∂–µ–Ω'); console.log('CSS —Ñ–∞–π–ª—ã:', Array.from(s.currentPageSelectors)); console.log('–°–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ –Ω–∞–π–¥–µ–Ω–æ:', s.unusedSelectors.size); const safeCount = Array.from(s.unusedSelectors.values()).filter(info => info.safe).length; console.log('–ü—Ä–æ–≤–µ—Ä—è–µ–º—ã—Ö:', safeCount); window.unusedCSSState = s; } catch (error) { console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error); } }
        static async loadStyleSheets() { const sheets = Array.from(document.styleSheets); for (const sheet of sheets) { try { const relativePath = CSSUtils.getRelativePathFromHref(sheet.href); if (s.currentPageSelectors.has(relativePath)) { await RuleProcessor.processStyleSheet(sheet); } } catch (error) { console.warn('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏:', sheet.href, error); } } }
        static startPeriodicCheck() { SelectorManager.checkSelectorsUsage(); setInterval(() => { if (!s.isProcessing) { SelectorManager.checkSelectorsUsage(); } }, c.CHECK_INTERVAL); }
    }
    class DOMChangeHandler { static init() { const observer = new MutationObserver((mutations) => { let shouldCheck = false; mutations.forEach((mutation) => { if (mutation.type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) { shouldCheck = true; } else if (mutation.type === 'attributes' && (mutation.attributeName === 'class' || mutation.attributeName === 'id')) { shouldCheck = true; } }); if (shouldCheck && !s.isProcessing) { clearTimeout(this.checkTimeout); this.checkTimeout = setTimeout(() => { SelectorManager.checkSelectorsUsage(); }, 100); } }); observer.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class', 'id'] }); } }
    function startApp() { if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => { UnusedCSSDetector.init(); DOMChangeHandler.init(); }); } else { UnusedCSSDetector.init(); DOMChangeHandler.init(); } } startApp();
})();
